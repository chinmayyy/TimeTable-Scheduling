%% SELECTIONS OF COURSES

%% Import data from spreadsheet
% Script for importing data from the following spreadsheet:
%
%    Workbook: /media/backslash/2TB/Matlab/Chinmay/Timetable/Final Project/SemData_MATRIX.xlsx
%    Worksheet: SemReg-b12-5 (3)
%
% Auto-generated by MATLAB on 25-Jun-2019 17:37:14

%% Setup the Import Options
opts = spreadsheetImportOptions("NumVariables", 53);

% Specify sheet and range
opts.Sheet = "SemReg-b12-5 (3)";
opts.DataRange = "A3:BA208";

% Specify column names and types
opts.VariableNames = ["BIO310", "BIO311", "BIO313", "BIO314", "BIO315", "BIO316", "BIO320", "BIO321", "BIO410", "BIO411", "BIO415", "CHM311", "CHM312", "CHM320", "ECS310", "ECS312", "ECS313", "ECS335", "ECS420", "HSS334", "MTH310", "MTH311", "MTH312", "MTH314", "MTH315", "MTH318", "MTH435", "MTH436", "PHY310", "PHY311", "PHY312", "PHY313", "BIO301", "BIO355", "BIO431", "BIO454", "CHM301", "CHM331", "CHM332", "CHM340", "ECS301", "ECS317", "ECS330", "ECS331", "HSS333", "HSS342", "HSS351", "MTH301", "PHY301", "PHY330", "PHY334", "PHY340", "PHY462"];
opts.SelectedVariableNames = ["BIO310", "BIO311", "BIO313", "BIO314", "BIO315", "BIO316", "BIO320", "BIO321", "BIO410", "BIO411", "BIO415", "CHM311", "CHM312", "CHM320", "ECS310", "ECS312", "ECS313", "ECS335", "ECS420", "HSS334", "MTH310", "MTH311", "MTH312", "MTH314", "MTH315", "MTH318", "MTH435", "MTH436", "PHY310", "PHY311", "PHY312", "PHY313", "BIO301", "BIO355", "BIO431", "BIO454", "CHM301", "CHM331", "CHM332", "CHM340", "ECS301", "ECS317", "ECS330", "ECS331", "HSS333", "HSS342", "HSS351", "MTH301", "PHY301", "PHY330", "PHY334", "PHY340", "PHY462"];
opts.VariableTypes = ["double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double"];

% Setup rules for import
opts = setvaropts(opts, [1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53], "FillValue", 0);

% Import the data
course_selections = readtable("/media/backslash/2TB/Matlab/Chinmay/Timetable/Final Project/SemData_MATRIX.xlsx", opts, "UseExcel", false);

%% Convert to output type
course_selections = table2array(course_selections);

%% Clear temporary variables
clear opts

%% CREDITS AND COURSES

%% Import data from spreadsheet
% Script for importing data from the following spreadsheet:
%
%    Workbook: /media/backslash/2TB/Matlab/Chinmay/Timetable/Final Project/SemData_MATRIX.xlsx
%    Worksheet: SemReg-b12-5 (3)
%
% Auto-generated by MATLAB on 25-Jun-2019 17:49:33

%% Setup the Import Options
opts = spreadsheetImportOptions("NumVariables", 53);

% Specify sheet
opts.Sheet = "SemReg-b12-5 (3)";

% Specify column names and types
opts.VariableNames = ["BIO310", "BIO311", "BIO313", "BIO314", "BIO315", "BIO316", "BIO320", "BIO321", "BIO410", "BIO411", "BIO415", "CHM311", "CHM312", "CHM320", "ECS310", "ECS312", "ECS313", "ECS335", "ECS420", "HSS334", "MTH310", "MTH311", "MTH312", "MTH314", "MTH315", "MTH318", "MTH435", "MTH436", "PHY310", "PHY311", "PHY312", "PHY313", "BIO301", "BIO355", "BIO431", "BIO454", "CHM301", "CHM331", "CHM332", "CHM340", "ECS301", "ECS317", "ECS330", "ECS331", "HSS333", "HSS342", "HSS351", "MTH301", "PHY301", "PHY330", "PHY334", "PHY340", "PHY462"];
opts.SelectedVariableNames = ["BIO310", "BIO311", "BIO313", "BIO314", "BIO315", "BIO316", "BIO320", "BIO321", "BIO410", "BIO411", "BIO415", "CHM311", "CHM312", "CHM320", "ECS310", "ECS312", "ECS313", "ECS335", "ECS420", "HSS334", "MTH310", "MTH311", "MTH312", "MTH314", "MTH315", "MTH318", "MTH435", "MTH436", "PHY310", "PHY311", "PHY312", "PHY313", "BIO301", "BIO355", "BIO431", "BIO454", "CHM301", "CHM331", "CHM332", "CHM340", "ECS301", "ECS317", "ECS330", "ECS331", "HSS333", "HSS342", "HSS351", "MTH301", "PHY301", "PHY330", "PHY334", "PHY340", "PHY462"];
opts.VariableTypes = ["double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double"];

% Import the data
credits = table;
ranges = ["A1:BA1", "A3:BA3"];
for idx = 1:length(ranges)
    opts.DataRange = ranges(idx);
    tb = readtable("/media/backslash/2TB/Matlab/Chinmay/Timetable/Final Project/SemData_MATRIX.xlsx", opts, "UseExcel", false);
    credits = [credits; tb]; %#ok<AGROW>
end

%% Convert to output type
credits = table2array(credits);

%% Clear temporary variables
clear idx opts ranges tb
credits = credits'

%% GENERATE EVENTS ARRAY

n = sum(credits(:,2))
e = [1:n]
cred_select = []
for i = 1:length(course_selections(1,:))
    credit = course_selections(1,i)
    for j= 1:credit
        cred_select = [cred_select course_selections(2:end,i)]
        cred_select
    end
end

%% GENERATE TIMESLOTS ARRAY
% Assigned number of time slots per day = 6
% Hence, total number of timeslots in a week (k)= 30
% These are labelled from 1 to k, 1 being the first time slot of Monday,
% and k being the last time slot of Friday.
k = 30
t = [1:k]

%% GENERATE STUDENTS ARRAY
% Total number of students in the batch is given by |s|.
s_number = length(course_selections(2:end,1))
s = [1:s_number]

%% GENERATE CLASS-ROOMS ARRAY along with individual capacities
% (Estimated Guess of the number of rooms) 
% 4 tutorial rooms on the ground floor of LHC, 4 Class rooms on the first
% floor, 2 class rooms on the 2nd floor. Each of these have an approximate
% capacity of 80. LHC101 has a capacity of 150, and LHC 103 has a capacity
% of 250.
% Capacities of each room are given by array 'cr'. 
% Temporarily, assume all the capacities to be equal. 

numberof_rooms = 12
r = [1:numberof_rooms]

cr = 80 .* ones(1,numberof_rooms)

%% P MATRICES
% Check out the user guide for details

% Attends Matrix (s x n)
P1 = cred_select

% Room features
%P2 = zeros(r,1) %% NOT NEEDED

% Event Features 
% P3     || NOT NEEDED

% Event Availability (n x k)
P4 = ones(n,k)

% Precedence
P5 = zeros(n,n)

%% MATRICES TO CHECK HARD CONSTRAINT VIOLATIONS

% Room Suitability Matrix (n x r)
R = zeros(n,numberof_rooms);
ss = sum(P1)
for i = 1:length(ss)
    for j = 1:numberof_rooms
        if ss(i) <= cr(j)
            R(i,j) = 1;
        end
    end
end
R
% Conflicts Matrix (n , n)

C = zeros(n,n)
for l=1:s_number
    for i=1:n
        if P1(l,i)==1 
            for j=1:n
                if P1(l,j) == 1
                    C(i,j) = 1;
                    C(j,i) = 1;
                end
            end
        end
    end
end

for l = 1:numberof_rooms
    for i = 1:n
        for j = 1:n
            if R(i,l) == 1
                if R(j,l) == 1
                    if sum(R(i,:)')== 1
                        if sum(R(j,:)') == 1
                            C(i,j)=1;
                            C(j,i) = 1;
                        end
                    end
                end
            end
        end
    end
end

for i =1:n
    for j = 1:n
        if P5(i,j) ~= 0
            C(i,j) =1;
            C(j,i) = 1;
        end
    end
end

C = C .* (1 - eye(n,n))

c_ex = 1 - C
c_ex = c_ex .* (1 - eye(n,n))

figure
spy(C)
title('Conflict Matrix')

figure
spy(c_ex)
title('Excitatory Matrix')

%% Initiate Girvan Newman Clustering

G = digraph(C)
%{
%% APPLY BETWEENNESS CENTRALITY FUNCTION

s = sparse(A)

[bc,E] = betweenness_centrality(s)
%}

VV = GCModulMax3(C)
[com,Q] = fast_newman(C)

%% FUNCTIONS
function W=PermMat(N)
% function W=PermMat(N)
% 
% Creates an N-by-N permutation matrix W
%
% INPUT
% N     size of permutation matrix
%
% OUTPUT
% W     the permutation matrix: N-by-N matrix with exactly one 1 in every
%       row and column, all other elements equal to 0
%
% EXAMPLE
% W=PermMat(10);
%
W=zeros(N,N);
q=randperm(N);
for n=1:N; 
	W(q(n),n)=1; 
end
end


function VV= GCModulMax3(A)
% function VV= GCModulMax3(A)
% Modularity Maximization community detection
%
% This is a front end for fast_newman.m, E. le Martelot's implementation 
% of Newman's greedy agglomaerative modularity maximization method
% Newman, Mark EJ. "Fast algorithm for detecting community structure in 
% networks." Physical review E 69.6 (2004): 066133. 
%
% INPUT
% A:      Adjacency matrix of graph
%
% OUTPUT
% VV:     N-by-1 matrix, VV(n) is the cluster to which node n belongs 
%
% EXAMPLE
% [A,V0]=GGGirvanNewman(32,4,16,0,0);
% VV=GCModulMax3(A);
%
N=length(A);
W=PermMat(N);                     % permute the graph node labels
A=W*A*W';
[VV,Q] = fast_newman(A);
VV=W'*VV;                         % unpermute the graph node labels
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Modularity optimisation based on a greedy agglomerative method
%
% Input
%   - adj: (symmetrical) adjacency matrix
%
% Output
%   - com: communities (listed for each node)
%   - Q  : modularity value of the given partition
%
% Author: Erwan Le Martelot
% Date: 23/11/10
function [com,Q] = fast_newman(adj)
    % Set initial communities with one node per community
    cur_com = [1:length(adj)]';
    % Initialise best community to current value
    com = cur_com;
    % Compute initial community matrix
    e = get_community_matrix(adj,com);
    % Lines and columns sum (speed optimisation)
    ls = sum(e,2);
    cs = sum(e,1);
    % Initialise best known and current Q values
    cur_Q = trace(e) - sum(sum(e^2));
    Q = cur_Q;
    % Loop until no more aggregation is possible
    while length(e) > 1
        % Print progress
        %fprintf('Loop %d/%d...',length(adj)-length(e)+1,length(adj));
        %tic
        % Best Q variation
        loop_best_dQ = -inf;
        % For all the pairs of nodes that could be merged
        can_merge = false;
        for i=1:length(e)
            for j=i+1:length(e)
                % If they share edges
                if e(i,j) > 0
                    % Compute the variation in Q
                    dQ = 2 * (e(i,j) - ls(i)*cs(j));
                    % If best variation, then keep track of the pair
                    if dQ > loop_best_dQ
                        loop_best_dQ = dQ;
                        best_pair = [i,j];
                        can_merge = true;
                    end
                end
            end
        end
        if ~can_merge
            disp('!!! Graph with isolated communities, no more merging possible !!!');
            break;
        end
        % Merge the pair of clusters maximising Q
        best_pair = sort(best_pair);
        for i=1:length(cur_com)
            if cur_com(i) == best_pair(2)
                cur_com(i) = best_pair(1);
            elseif cur_com(i) > best_pair(2)
                cur_com(i) = cur_com(i) - 1;
            end    
        end
        % Update community matrix
        % Slow way (for precision comparison)
        %e = get_community_matrix(adj,com);
        % Faster way
        e(best_pair(1),:) = e(best_pair(1),:) + e(best_pair(2),:);
        e(:,best_pair(1)) = e(:,best_pair(1)) + e(:,best_pair(2));
        e(best_pair(2),:) = [];
        e(:,best_pair(2)) = [];
        % Update lines/colums sum
        ls(best_pair(1)) = ls(best_pair(1)) + ls(best_pair(2));
        cs(best_pair(1)) = cs(best_pair(1)) + cs(best_pair(2));
        ls(best_pair(2)) = [];
        cs(best_pair(2)) = [];
        % Update Q value
        cur_Q = cur_Q + loop_best_dQ;
        % Check consistency
        %eqQ = trace(e) - sum(sum(e*e));
        %if Q ~= eqQ
        %    fprintf('Warning: found Q=%d, should be Q=%d. Diff = %d\n',Q,eqQ,abs(Q-eqQ));
        %end
        % If new Q is better, save current partition
        if cur_Q > Q
            Q = cur_Q;
            com = cur_com;
        end
        %fprintf(' completed in %f(s)\n',toc);
    end
end